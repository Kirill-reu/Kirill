1)Блочная (корзинная) сортировка
---------------------------------
Определение: Блочная (корзинная) сортировка - это это алгоритм, который распределяет элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их значений. После этого каждая корзина сортируется отдельно (либо тем же методом рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины объединяются обратно в один массив.

Принцип работы:
- buckets = [[] for _ in range(len(arr))] - создание пустых корзин
- int(num * len(arr) / (max(arr) + 1)) - вычисление индекса корзины на основе значения элемента
- bucket.sort() - сортировка отдельных корзин
- result.extend(bucket) - объединение отсортированных корзин

Временная сложность: 
 - Лучший случай: O(n) - когда элементы равномерно распределены
 - Средний случай: O(n + k) - где k - количество корзин
 - Худший случай: O(n²) - когда все элементы попадают в одну корзину

Объяснение сложности: Сложность зависит от равномерности распределения данных. При равномерном распределении каждый элемент попадает в свою корзину, и сортировка выполняется за линейное время.

2)Блинная сортировка
-----------------
Определение: Блинная сортировка (pancake sort) — это метод, основанный на операции переворота (reversal) части массива. В отличие от большинства алгоритмов, которые обменивают соседние элементы или выбирают опорные точки, здесь единственная разрешённая операция — переворот префикса массива до выбранного индекса.

Принцип работы:
 - arr[:max_index + 1][::-1] - переворот префикса массива
 - arr.index(max(arr[:curr_size])) - поиск максимального элемента в неотсортированной части
 - Двойной переворот перемещает максимальный элемент на правильную позицию

Временная сложность: O(n²)

Объяснение сложности: Для каждого элемента выполняем поиск максимума (O(n)) и два переворота (O(n)), что в итоге дает O(n²).

3)Сортировка бусинами (гравитационная)
--------------------------------
Определение: Сортировка бусинами (bead sort), также известная как гравитационная сортировка, моделирует естественное поведение бусин, падающих вниз под действием гравитации. Этот алгоритм разработали Джошуа Аруланандхам, Кристиан Калюд и Майкл Диннин в 2002 году. 

Принцип работы:
 - bead_grid - представление бусин в виде матрицы
 - Двойной цикл размещает бусины согласно значениям массива
 - Подсчет и перераспределение бусин имитирует гравитацию

Временная сложность: O(n) или O(S), где S - сумма элементов

Объяснение сложности: Хотя теоретически алгоритм имеет линейную сложность, на практике она зависит от максимального значения в массиве и реализации "падения" бусин.

4)Поиск скачками
---------------
Определение: Поиск скачками — это оптимизация линейного поиска для отсортированных массивов, при которой алгоритм «прыгает» через определённое число элементов (обычно через n), чтобы быстро сузить диапазон поиска, а затем выполняет линейный поиск внутри найденного диапазона.

Принцип работы:
 - step = int(math.sqrt(n)) - оптимальный размер прыжка
 - Первый цикл находит блок, где может находиться элемент
 - Второй цикл выполняет линейный поиск в этом блоке

Временная сложность: O(√n)

Объяснение сложности: Алгоритм делает √n прыжков, а затем выполняет линейный поиск в блоке размером √n, что в сумме дает O(√n).

5)Экспоненциальный поиск
----------------------
Определение:Экспоненциальный поиск сочетает идеи последовательного и бинарного поиска, позволяя 
быстро определить диапазон, в котором может находиться искомое значение, а затем 
применяет двоичный поиск в этом диапазоне. 

Принцип работы:
 - bound *= 2 - экспоненциальное увеличение границы поиска
 - binary_search() - бинарный поиск в суженном диапазоне

Временная сложность: O(log n)

Объяснение сложности: Экспоненциальное нахождение границы занимает O(log i), где i - позиция элемента, а бинарный поиск - O(log n), что в сумме дает O(log n).

6)Тернарный поиск
----------------
Определение: Тернарный поиск — это метод деления диапазона поиска на три части (в отличие от двух в бинарном) и рекурсивного сужения диапазона до тех пор, пока не будет найден элемент или экстремум функции (в зависимости от задачи).

Принцип работы:
 - mid1 = left + (right - left) // 3 - первая точка деления
 - mid2 = right - (right - left) // 3 - вторая точка деления
 - Рекурсивный поиск в одной из трех частей

Временная сложность: O(log₃n)

Объяснение сложности: На каждом шаге поисковое пространство уменьшается в 3 раза, что дает логарифмическую сложность с основанием 3. Хотя асимптотически это эквивалентно O(log n), количество сравнений на каждом шаге больше, чем в бинарном поиске.
