1)Блочная (корзинная) сортировка
---------------------------------
Определение: Блочная (корзинная) сортировка - это это алгоритм, который распределяет элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их значений. После этого каждая корзина сортируется отдельно (либо тем же методом рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины объединяются обратно в один массив.

Принцип работы:
- buckets = [[] for _ in range(len(arr))] - создание пустых корзин
- int(num * len(arr) / (max(arr) + 1)) - вычисление индекса корзины на основе значения элемента
- bucket.sort() - сортировка отдельных корзин
- result.extend(bucket) - объединение отсортированных корзин

Временная сложность: 
 - Лучший случай: O(n) - когда элементы равномерно распределены
 - Средний случай: O(n + k) - где k - количество корзин
 - Худший случай: O(n²) - когда все элементы попадают в одну корзину

Объяснение сложности: 
 - В лучшем случае, когда данные распределены равномерно, все элементы попадают в разные корзины или корзины имеют примерно одинаковый небольшой размер. Если для сортировки корзины используется алгоритм с сложностью O(m log m) (например, быстрая сортировка), и размер каждой корзины m близок к константе, то сортировка всех корзин займет время O(n). Почему? Потому что n/k * O(k log k) ≈ O(n log k), и если k пропорционально n, а данные распределены идеально, то log k становится константой. В идеальном случае, когда в каждой корзине не более одного элемента, сортировка вообще не требуется. Таким образом, общая сложность становится O(n) (распределение) + O(k) (объединение) ≈ O(n + k), где k — количество корзин.
 - В худшем случае, все элементы попадают в одну и ту же корзину. Тогда блочная сортировка вырождается в тот алгоритм, который используется для сортировки внутри корзины. Если это сортировка вставками, сложность будет O(n²). Если быстрая сортировка — тоже O(n²) в худшем случае.

2)Блинная сортировка
-----------------
Определение: Блинная сортировка (pancake sort) — это метод, основанный на операции переворота (reversal) части массива. В отличие от большинства алгоритмов, которые обменивают соседние элементы или выбирают опорные точки, здесь единственная разрешённая операция — переворот префикса массива до выбранного индекса.

Принцип работы:
 - arr[:max_index + 1][::-1] - переворот префикса массива
 - arr.index(max(arr[:curr_size])) - поиск максимального элемента в неотсортированной части
 - Двойной переворот перемещает максимальный элемент на правильную позицию

Временная сложность: O(n²)

Объяснение сложности: 
 - Для каждого неотсортированного подмассива (размером n, n-1, n-2, ...) выполняется линейный поиск максимального элемента. Количество сравнений: n + (n-1) + (n-2) + ... + 1 = O(n²)
 - Для каждого найденного максимума выполняется два переворота: один чтобы переместить его в начало подмассива, другой — чтобы переместить в конец. Каждый переворот подмассива размера m — это операция O(m). В сумме это также дает O(n²)

3)Сортировка бусинами (гравитационная)
--------------------------------
Определение: Сортировка бусинами (bead sort), также известная как гравитационная сортировка, моделирует естественное поведение бусин, падающих вниз под действием гравитации. Этот алгоритм разработали Джошуа Аруланандхам, Кристиан Калюд и Майкл Диннин в 2002 году. 

Принцип работы:
 - bead_grid - представление бусин в виде матрицы
 - Двойной цикл размещает бусины согласно значениям массива (for i, num in enumerate(arr) и for j in range(num))
 - Подсчет и перераспределение бусин имитирует гравитацию

Временная сложность: O(n) или O(S), где S - сумма элементов

Объяснение сложности: 
 - Для реализации этого шага обычно создается двумерная сетка (матрица) размером max(input) x n. Каждый столбец представляет число, а количество "бусин" в нем — значение числа. Процесс "падения" требует, чтобы каждая бусина упала на свою позицию. В наихудшем случае, если все числа равны m, то общее количество бусин равно S = n * m. Каждая бусина должна "упасть" на m позиций вниз. В наивной реализации это приводит к сложности O(n * m) = O(S)
 - После падения необходимо пройти по всей сетке, чтобы считать отсортированные значения, что также занимает O(n * m)

4)Поиск скачками
---------------
Определение: Поиск скачками — это оптимизация линейного поиска для отсортированных массивов, при которой алгоритм «прыгает» через определённое число элементов (обычно через n), чтобы быстро сузить диапазон поиска, а затем выполняет линейный поиск внутри найденного диапазона.

Принцип работы:
 - step = int(math.sqrt(n)) - оптимальный размер прыжка
 - Первый цикл находит блок, где может находиться элемент (while arr[min(step, n)-1] < x)
 - Второй цикл выполняет линейный поиск в этом блоке (while arr[prev] < x)

Временная сложность: O(√n)

Объяснение сложности:
 - Алгоритм прыгает через блоки фиксированного размера m. Оптимальный размер блока, минимизирующий общее количество операций, равен m = √n. В этом случае количество прыжков будет O(n/m) = O(√n)
 - После того как найден блок, в котором может находиться элемент, в нем выполняется линейный поиск. Поскольку размер блока равен m = √n, эта фаза также займет O(√n) операций.

5)Экспоненциальный поиск
----------------------
Определение:Экспоненциальный поиск сочетает идеи последовательного и бинарного поиска, позволяя 
быстро определить диапазон, в котором может находиться искомое значение, а затем 
применяет двоичный поиск в этом диапазоне. 

Принцип работы:
 - bound *= 2 - экспоненциальное увеличение границы поиска
 - binary_search() - бинарный поиск в суженном диапазоне

Временная сложность: O(log n)

Объяснение сложности:
 - Алгоритм экспоненциально увеличивает границу поиска: 1, 2, 4, 8, ... пока не будет найден диапазон, содержащий искомый элемент. Если индекс элемента равен i, то для его нахождения потребуется O(log i) шагов. Например, чтобы дойти до индекса 16, потребуется 5 шагов (1->2->4->8->16)
 - После того как диапазон размером от i/2 до i найден, в нем выполняется бинарный поиск. Размер этого диапазона пропорционален i, поэтому бинарный поиск в нем займет O(log i)

6)Тернарный поиск
----------------
Определение: Тернарный поиск — это метод деления диапазона поиска на три части (в отличие от двух в бинарном) и рекурсивного сужения диапазона до тех пор, пока не будет найден элемент или экстремум функции (в зависимости от задачи).

Принцип работы:
 - mid1 = left + (right - left) // 3 - первая точка деления
 - mid2 = right - (right - left) // 3 - вторая точка деления
 - Рекурсивный поиск в одной из трех частей 

Временная сложность: O(log₃n)

Объяснение сложности: На каждом шаге алгоритм отбрасывает одну треть текущего диапазона поиска. Размер диапазона уменьшается в 3 раза на каждой итерации. Вопрос: "Сколько раз нужно разделить массив размера n на три части, чтобы получить диапазон размером 1?" Ответ: log₃ n.
