1)Алгоритм сортировки выбором
------------------------------------------
Алгоритм сортировки выбором - это алгоритм, который принимает массив целых чисел и сортирует его по возрастанию. Он проходит по массиву, находя минимальный элемент и помещая его в начало неотсортированной части массива.

Объяснение работы кода: Внешний цикл for перебирает каждую позицию в массиве, начиная с первой. Внутренний цикл for ищет минимальный элемент в оставшейся неотсортированной части массива. Когда минимальный элемент найден, он меняется местами с элементом на текущей позиции.

Временная сложность этого алгоритма — O(n²). Алгоритм всегда выполняет одинаковое количество сравнений независимо от исходного порядка элементов, поэтому сложность всегда квадратичная.

При запуске кода на примере массива [64, 25, 12, 22, 11] получим отсортированный массив [11, 12, 22, 25, 64].

2)Алгоритм сортировки обменом (пузырьком)
------------------------------------------------------------------------------------------------
Алгоритм сортировки обменом (пузырьком) - это алгоритм, который работает, сравнивая соседние элементы и меняя их местами, если они стоят в неправильном порядке. Этот процесс повторяется до тех пор, пока весь список не будет отсортирован.

Объяснение работы кода: Сначала у нас есть функция bubble_sort, которая принимает массив arr. Затем мы определяем длину массива и запускаем два цикла. Внутренний цикл сравнивает соседние элементы и меняет их местами, если они в неправильном порядке. Этот процесс повторяется, пока весь массив не будет отсортирован. В конце мы выводим отсортированный массив.

Временная сложность этого алгоритма — O(n²), но в лучшем случае — O(n)

При запуске кода на примере массива [64, 34, 25, 12, 22, 11, 90] получим отсортированный массив [11, 12, 22, 25, 34, 64, 90].

3)Алгоритм сортировки вставками
------------------------
Алгоритм сортировки вставками - это алгоритм, который строит отсортированный массив, помещая каждый элемент в нужное место в уже отсортированной части массива. Этот процесс повторяется, пока весь массив не станет упорядоченным.

Объяснение работы кода: Внешний цикл for i in range(1, len(arr)): проходит по массиву, начиная со второго элемента (индекс 1). key = arr[i] : текущий элемент, который мы пытаемся установить в правильное место. j = i - 1 : это индекс предыдущего элемента. Внутренний цикл while j >= 0 and key < arr[j]: продолжает двигать элементы массива вправо, пока не найдет место для key. arr[j + 1] = arr[j] : перемещает элемент arr[j] на одну позицию вправо. j -= 1 : : уменьшает индекс j, чтобы сравнить key со следующим элементом слева. arr[j + 1] = key : : вставляет key на правильную позицию.

Временная сложность этого алгоритма — O(n²), но в лучшем случае — O(n)

При запуске кода на примере массива [5, 2, 8, 12, 1, 6, 21] получим отсортированный массив [1, 2, 5, 6, 8, 12, 21].

4)Алгоритм сортировки слиянием
--------------------------------
Алгоритм сортировки слиянием - это алгоритм, который разбивает массив на более мелкие части, сортирует их рекурсивно, а затем объединяет эти части в один отсортированный массив.

Объяснение работы кода: Сначала алгоритм рекурсивно делит массив на более мелкие части, пока каждая часть не будет состоять из одного элемента, а затем объединяет отсортированные части, чтобы получить больший отсортированный массив.

Временная сложность этого алгоритма — O(n log n)

При запуске кода на примере массива [12, 11, 16, 13, 5, 6, 7] получим отсортированный массив [5, 6, 7, 11, 12, 13, 16].

5)Алгоритм сортировки Шелла
--------------------------------
Алгоритм сортировки Шелла - это алгоритм, который является вариацией алгоритма сортировки вставками. Он сортирует между собой элементы, стоящие на местах, кратных определённому шагу. Этот алгоритм является более эффективным, чем обычная сортировка вставками.

Объяснение работы кода: 1. Выбирается шаг сортировки, который на каждой последующей итерации уменьшается. 2. Массив сортируется пошагово, то есть элементы, находящиеся друг от друга на расстоянии шага, сравниваются и меняются местами, если это необходимо. 3. Процесс повторяется, пока шаг сортировки не станет равным 1, что эк равносильно обычной сортировке вставками.

Временная сложность этого алгоритма — O(n^(3/2)) или O(n log² n), но может быть и хуже

При запуске кода на примере массива [64, 34, 25, 12, 22, 11, 90] получим отсортированный массив [11, 12, 22, 25, 34, 64, 90].

6)Алгоритм быстрой сортировки
------------------------------------
Алгоритм быстрой сортировки - это алгоритм, который 
