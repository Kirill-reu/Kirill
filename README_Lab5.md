1)Алгоритм сортировки выбором
------------------------------------------
*Алгоритм сортировки выбором* - это алгоритм, который принимает массив целых чисел и сортирует его по возрастанию. Он проходит по массиву, находя минимальный элемент и помещая его в начало неотсортированной части массива.

*Объяснение работы кода*: Внешний цикл for перебирает каждую позицию в массиве, начиная с первой. Внутренний цикл for ищет минимальный элемент в оставшейся неотсортированной части массива. Когда минимальный элемент найден, он меняется местами с элементом на текущей позиции.

*Временная сложность этого алгоритма* — O(n²). Алгоритм всегда выполняет одинаковое количество сравнений независимо от исходного порядка элементов, поэтому сложность всегда квадратичная.

При запуске кода на примере массива [64, 25, 12, 22, 11] получим отсортированный массив [11, 12, 22, 25, 64].

2)Алгоритм сортировки обменом (пузырьком)
------------------------------------------------------------------------------------------------
*Алгоритм сортировки обменом (пузырьком)* - это алгоритм, который работает, сравнивая соседние элементы и меняя их местами, если они стоят в неправильном порядке. Этот процесс повторяется до тех пор, пока весь список не будет отсортирован.

*Объяснение работы кода*: Сначала у нас есть функция bubble_sort, которая принимает массив arr. Затем мы определяем длину массива и запускаем два цикла. Внутренний цикл сравнивает соседние элементы и меняет их местами, если они в неправильном порядке. Этот процесс повторяется, пока весь массив не будет отсортирован. В конце мы выводим отсортированный массив.

*Временная сложность этого алгоритма* — O(n²), но в лучшем случае — O(n). Если массив уже отсортирован, то его временная сложность будет O(n), т.к после первого прохода (n-1 сравнений) алгоритм завершается. Иначе его временна сложность будет всегда O(n²), т.к общее кол-во сравнений n-1) + (n-2) + ... + 1 = n(n-1)/2 -> n(n-1)/2 = (n² - n)/2 → O(n²). 

При запуске кода на примере массива [64, 34, 25, 12, 22, 11, 90] получим отсортированный массив [11, 12, 22, 25, 34, 64, 90].

3)Алгоритм сортировки вставками
------------------------
*Алгоритм сортировки вставками* - это алгоритм, который строит отсортированный массив, помещая каждый элемент в нужное место в уже отсортированной части массива. Этот процесс повторяется, пока весь массив не станет упорядоченным.

*Объяснение работы кода*: Внешний цикл for i in range(1, len(arr)): проходит по массиву, начиная со второго элемента (индекс 1). key = arr[i] : текущий элемент, который мы пытаемся установить в правильное место. j = i - 1 : это индекс предыдущего элемента. Внутренний цикл while j >= 0 and key < arr[j]: продолжает двигать элементы массива вправо, пока не найдет место для key. arr[j + 1] = arr[j] : перемещает элемент arr[j] на одну позицию вправо. j -= 1 : : уменьшает индекс j, чтобы сравнить key со следующим элементом слева. arr[j + 1] = key : : вставляет key на правильную позицию.

*Временная сложность этого алгоритма* — O(n²), но в лучшем случае — O(n). Если массив уже отсортирован, то его временная сложность будет O(n), т.к после первого прохода (n-1 сравнений) алгоритм завершается. Иначе его временна сложность будет всегда O(n²), т.к он делает общее кол-во операций ~n²/4 → O(n²).

При запуске кода на примере массива [5, 2, 8, 12, 1, 6, 21] получим отсортированный массив [1, 2, 5, 6, 8, 12, 21].

4)Алгоритм сортировки слиянием
--------------------------------
*Алгоритм сортировки слиянием* - это алгоритм, который разбивает массив на более мелкие части, сортирует их рекурсивно, а затем объединяет эти части в один отсортированный массив.

*Объяснение работы кода*: Сначала алгоритм рекурсивно делит массив на более мелкие части, пока каждая часть не будет состоять из одного элемента, а затем объединяет отсортированные части, чтобы получить больший отсортированный массив.

*Временная сложность этого алгоритма* — O(n log n). У этого алгоритма всегда такая временная сложность, потому что: он всегда делит массив пополам, всегда требует O(n) операций независимо от исходного порядка, не зависит от входных данных. Общая сложность: O(n) × O(log n) = O(n log n).

При запуске кода на примере массива [12, 11, 16, 13, 5, 6, 7] получим отсортированный массив [5, 6, 7, 11, 12, 13, 16].

5)Алгоритм сортировки Шелла
--------------------------------
*Алгоритм сортировки Шелла* - это алгоритм, который является вариацией алгоритма сортировки вставками. Он сортирует между собой элементы, стоящие на местах, кратных определённому шагу. Этот алгоритм является более эффективным, чем обычная сортировка вставками.

*Объяснение работы кода*: 1. Выбирается шаг сортировки, который на каждой последующей итерации уменьшается. 2. Массив сортируется пошагово, то есть элементы, находящиеся друг от друга на расстоянии шага, сравниваются и меняются местами, если это необходимо. 3. Процесс повторяется, пока шаг сортировки не станет равным 1, что эк равносильно обычной сортировке вставками.

*Временная сложность этого алгоритма* — O(n^(3/2)) или O(n log² n), но может быть и хуже. Это достигается за счёт того, что на каждом шаге сортируются подмассивы с элементами, расположенными на определённом расстоянии друг от друга, что уменьшает количество перемещений, необходимых для полной сортировки.

При запуске кода на примере массива [64, 34, 25, 12, 22, 11, 90] получим отсортированный массив [11, 12, 22, 25, 34, 64, 90].

6)Алгоритм быстрой сортировки
------------------------------------
*Алгоритм быстрой сортировки* - это алгоритм, который выбирает опорный элемент, разделяет массив на элементы меньше опорного и больше опорного, а затем рекурсивно сортирует части.

*Объяснение работы кода*: 1)Выбирается опорный элемент (pivot). 2)Массив разделяется на три части: < pivot, = pivot, > pivot. 3)Рекурсивно сортируются левую и правую части

*Временная сложность этого алгоритма* — O(n log n), когда pivot всегда делит массив пополам. Но в худшем случае может быть O(n²), когда pivot всегда минимальный или максимальный элемент. Количество делений до размера 1: log₂n уровней, O(n/2) + O(n/2) = O(n) - разделение двух половин и O(n/4) × 4 = O(n) - разделение четырех четвертей, поэтому получается O(n) × O(log n) = O(n log n)

При запуске кода на примере массива [5, 2, 8, 12, 1, 6, 21] получим отсортированный массив [1, 2, 5, 6, 8, 12, 21].

7)Алгоритм пирамидальной сортировки
--------------------------
*Алгоритм пирамидальной сортировки* - это алгоритм, который использует структуру данных "двоичная куча" для сортировки.

*Объяснение работы кода*:

1)Построение максимальной кучи (Heapify). Максимальная куча — это бинарное дерево, в котором значение каждого родительского узла больше или равно значений его дочерних узлов. В реализации на массиве это означает, что элемент с индексом i всегда меньше или равен элементам с индексами 2i+1 (левый потомок) и 2i+2 (правый потомок).

2)Сортировка (Извлечение элементов). После построения максимальной кучи, самый большой элемент (корень кучи) находится в первой позиции массива. На втором этапе происходит итеративное извлечение максимального элемента и восстановление кучи:
​Обмен: Корень кучи (максимальный элемент) меняется местами с последним элементом текущей кучи.
​Уменьшение размера: Размер кучи уменьшается на 1 (теперь максимальный элемент находится в конце массива в своей правильной отсортированной позиции).
​Восстановление: На "новом" корне (который был последним элементом) снова вызывается процедура heapify, чтобы восстановить свойство максимальной кучи для оставшихся N-1 элементов.

3)​Повторение: Шаги 1-3 повторяются до тех пор, пока размер кучи не станет равным 1.

*Временная сложность этого алгоритма* — O(n log n), потому что: построение кучи O(n), каждое из n извлечений O(log n), и получается O(n) + O(n log n) = O(n log n).

При запуске кода на примере массива [64, 25, 12, 22, 11] получим отсортированный массив [11, 12, 22, 25, 64].

8)Алгоритм последовательного поиска
----------------------------------
*Алгоритм последовательного поиска* - это алгоритм, который выполняет поочередную проверку каждого элемента массива до нахождения искомого.

*Объяснение работы кода*: Алгоритм последовательно просматривает элементы массива, сравнивая их с нужным значением.

*Временная сложность этого алгоритма* — O(n), т.к он по очереди просматривает каждый элемент в массиве. Но в лучшем случае может быть O(1), если нужный элемент будет стоять на первом месте.

При запуске кода на примере массива [5, 12, 23, 8, 15]. Мы ищем число 8, то консоль выведет индекс 3 (при индексации с 0).

9)Алгоритм бинарного поиска
-----------------
*Алгоритм бинарного поиска* - это алгоритм, который
