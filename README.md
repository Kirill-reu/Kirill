Lab_6 - контрольная работа

Лаборараторная работа №1
--------------------------
 - Описание создания пустого списка на языках Python, Java, C++:

В Python для создания пустого списка достаточно написать квадратные скобки []. На языке Java для создания пустого списка нужно перед именем списка написать команду ArrayList и указать класс значений в списке. А в языке C++ нужно в начале указать директиву #include_list и библиотеку std::list после чего так же, как в Java, написать класс значений в списке.

 - Описание создания структуры stack на языках Python, Java, C++:

На языке Python достаточно создать пустой список и с помощью append добавлять элементы в список. В Java тоже создаётся пустой список и добавляются элементы с помощью команды add. На языке С++ нужно добавить директивы #include_list для создания списка и директиву #include_iosteam, после чего уже добавляются элементы в список с помощью push. 

Лабораторная работа №2
-------------------
 - Описание создания мультисписков на языках Python, Java, C++:

В Python для работы с структурой данных «мультисписок» используют циклы for и вложенные списки. В языке Java для создания мультисписка используется класс LinkedList из фреймворка Collections. В C++ похожая ситуация, но там вместо класса используется шаблон std::vector<>lists.

 - Описание создания очереди на языках Python, Java, C++:

Для создания очереди в Python есть модуль queue, который предоставляет класс Queue. В языке Java очередь можно создать с помощью интерфейса Queue и его реализацией LinkedList<>(). А в языке C++ для этого существеут контейнер queue из стандартной библиотеки шаблонов.

 - Описание реализации структуры дека на языках Python, Java, C++:

В языке Python для этого есть класс deque из модуля colltction. В языке Java есть интерфейс Deque и его реализация ArrayDeque<>(). А в языке C++ для этого используется контейнер deque из стандартной библиотеки.

 - Описание создания приоритетной очереди на языках Python, Java, C++:

На языке Python для создания приоритетной очереди есть модуль heapq и модуль queue, который предоставляет класс PriorityQueue. В Jave тоже для этого есть класс PriorityQueue. А в C++ используют контейнер priority_queue из стандартной библиотеки.

Лабораторная работа №3
----------------
 - Описание реализации бинарной кучи на языках Python, Java, C++:

 1) Python: Использует встроенный модуль heapq, который работает поверх обычного списка Python. Важно, что heapq реализует только минимальную кучу (min-heap). Для реализации максимальной кучи (max-heap) документ предлагает инвертировать значения (например, хранить -10 вместо 10). Также возможна реализация в виде собственного класса.
 2) Java: Также показана реализация собственного класса BinaryHeap. В отличие от примера на Python, этот класс гибко настраивается при создании для работы как max-heap или min-heap с помощью булевой переменной isMax. В качестве основы используется массив.
 3) C++: В документе представлен пример полной реализации собственного класса MinHeap с использованием шаблонов (template <typename T>). В качестве основы для хранения данных используется std::vector.

 - Описание создания биноминальной кучи на языках Python, Java, C++:

 1)  Python: Документ не предоставляет явной реализации биномиальной кучи на Python. Хотя она упоминается в заголовке, примеры кода показывают либо использование heapq (который является бинарной кучей), либо собственный класс бинарной кучи.
 2)  Java: Также показана полная реализация собственного класса BinomialHeap. Эта реализация использует вложенные классы HeapNode и HeapItem для управления структурой. Узел HeapNode содержит ссылки child, next (аналог sibling) и parent.
 3)  C++: Представлена полная реализация собственного класса BinomialHeap. Она основана на структуре node, которая содержит указатели на parent (родителя), child (потомка) и sibling (брата/соседа), что необходимо для представления коллекции биномиальных деревьев.

 - Описание реализации кучи Фибоначчи на языках Python, Java, C++:

 1) Python: Документ прямо утверждает, что в Python нет структуры данных «куча Фибоначчи». Вместо кучи в примерах показаны алгоритмы для работы с числами или последовательностью Фибоначчи (с использованием цикла и рекурсии).
 2) Java: Аналогично Python, документ не показывает реализацию кучи Фибоначчи. Вместо этого он описывает реализацию последовательности (Fibonacci Series) с помощью рекурсивного алгоритма для вычисления n-го числа Фибоначчи.
 3) C++: В документе указано, что встроенной структуры нет, но при этом приводится полная и сложная реализация «кучи Фибоначчи» в виде шаблонного класса FibonacciHeap<T>. Это единственная реализация настоящей кучи Фибоначчи в документе.

 - Описание реализации хэш-таблицы на языках Python, Java, C++:

 1) Python: Основной реализацией является встроенный тип данных dict (словарь). Документ также показывает примеры создания собственных классов HashTable, используя в качестве основы обычный список (массив).
 2) Java: Используются встроенные классы Hashtable и HashMap. Документ отмечает, что HashMap реализован на основе «массива односвязных списков».
 3) C++: Предоставляет два подхода: использование встроенного контейнера std::unordered_map из библиотеки STL или ручная реализация. Пример ручной реализации (HashTable<K, V>) явно использует массив связанных списков (std::list) для обработки коллизий (метод цепочек).
