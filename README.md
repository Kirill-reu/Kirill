Lab_6 - контрольная работа

Лаборараторная работа №1
--------------------------
 - Описание создания пустого списка на языках Python, Java, C++:

В Python для создания пустого списка достаточно написать квадратные скобки []. На языке Java для создания пустого списка нужно перед именем списка написать команду ArrayList и указать класс значений в списке. А в языке C++ нужно в начале указать директиву #include_list и библиотеку std::list после чего так же, как в Java, написать класс значений в списке.

 - Описание создания структуры stack на языках Python, Java, C++:

На языке Python достаточно создать пустой список и с помощью append добавлять элементы в список. В Java тоже создаётся пустой список и добавляются элементы с помощью команды add. На языке С++ нужно добавить директивы #include_list для создания списка и директиву #include_iosteam, после чего уже добавляются элементы в список с помощью push. 

Лабораторная работа №2
-------------------
 - Описание создания мультисписков на языках Python, Java, C++:

В Python для работы с структурой данных «мультисписок» используют циклы for и вложенные списки. В языке Java для создания мультисписка используется класс LinkedList из фреймворка Collections. В C++ похожая ситуация, но там вместо класса используется шаблон std::vector<>lists.

 - Описание создания очереди на языках Python, Java, C++:

Для создания очереди в Python есть модуль queue, который предоставляет класс Queue. В языке Java очередь можно создать с помощью интерфейса Queue и его реализацией LinkedList<>(). А в языке C++ для этого существеут контейнер queue из стандартной библиотеки шаблонов.

 - Описание реализации структуры дека на языках Python, Java, C++:

В языке Python для этого есть класс deque из модуля colltction. В языке Java есть интерфейс Deque и его реализация ArrayDeque<>(). А в языке C++ для этого используется контейнер deque из стандартной библиотеки.

 - Описание создания приоритетной очереди на языках Python, Java, C++:

На языке Python для создания приоритетной очереди есть модуль heapq и модуль queue, который предоставляет класс PriorityQueue. В Jave тоже для этого есть класс PriorityQueue. А в C++ используют контейнер priority_queue из стандартной библиотеки.

Лабораторная работа №3
----------------
 - Описание реализации бинарной кучи на языках Python, Java, C++:

 1) Python: Использует встроенный модуль heapq, который работает поверх обычного списка Python. Важно, что heapq реализует только минимальную кучу (min-heap). Для реализации максимальной кучи (max-heap) документ предлагает инвертировать значения (например, хранить -10 вместо 10). Также возможна реализация в виде собственного класса.
 2) Java: Также показана реализация собственного класса BinaryHeap. В отличие от примера на Python, этот класс гибко настраивается при создании для работы как max-heap или min-heap с помощью булевой переменной isMax. В качестве основы используется массив.
 3) C++: В документе представлен пример полной реализации собственного класса MinHeap с использованием шаблонов (template <typename T>). В качестве основы для хранения данных используется std::vector.

 - Описание создания биноминальной кучи на языках Python, Java, C++:

 1)  Python: Документ не предоставляет явной реализации биномиальной кучи на Python. Хотя она упоминается в заголовке, примеры кода показывают либо использование heapq (который является бинарной кучей), либо собственный класс бинарной кучи.
 2)  Java: Также показана полная реализация собственного класса BinomialHeap. Эта реализация использует вложенные классы HeapNode и HeapItem для управления структурой. Узел HeapNode содержит ссылки child, next (аналог sibling) и parent.
 3)  C++: Представлена полная реализация собственного класса BinomialHeap. Она основана на структуре node, которая содержит указатели на parent (родителя), child (потомка) и sibling (брата/соседа), что необходимо для представления коллекции биномиальных деревьев.

 - Описание реализации кучи Фибоначчи на языках Python, Java, C++:

 1) Python: Документ прямо утверждает, что в Python нет структуры данных «куча Фибоначчи». Вместо кучи в примерах показаны алгоритмы для работы с числами или последовательностью Фибоначчи (с использованием цикла и рекурсии).
 2) Java: Аналогично Python, документ не показывает реализацию кучи Фибоначчи. Вместо этого он описывает реализацию последовательности (Fibonacci Series) с помощью рекурсивного алгоритма для вычисления n-го числа Фибоначчи.
 3) C++: В документе указано, что встроенной структуры нет, но при этом приводится полная и сложная реализация «кучи Фибоначчи» в виде шаблонного класса FibonacciHeap<T>. Это единственная реализация настоящей кучи Фибоначчи в документе.

 - Описание реализации хэш-таблицы на языках Python, Java, C++:

 1) Python: Основной реализацией является встроенный тип данных dict (словарь). Документ также показывает примеры создания собственных классов HashTable, используя в качестве основы обычный список (массив).
 2) Java: Используются встроенные классы Hashtable и HashMap. Документ отмечает, что HashMap реализован на основе «массива односвязных списков».
 3) C++: Предоставляет два подхода: использование встроенного контейнера std::unordered_map из библиотеки STL или ручная реализация. Пример ручной реализации (HashTable<K, V>) явно использует массив связанных списков (std::list) для обработки коллизий (метод цепочек).

Лабораторная работа №4
--------------------
1. Описание реализации Деревьев на языках Python, Java, C++:
 - Python:
   1) Связи и Null: Используются ссылки на объекты, а в качестве "нулевой" ссылки выступает объект None.
   2) Классы: Реализация также использует классы (Node, Tree).
   3) Управление памятью: Полностью автоматическое (сборщик мусора), как и в Java.
   4) Вставка (нерекурсивная): Логика похожа на Java. Требуется поддерживать ссылку на текущий узел (v) и на его предка (parent). Когда v становится None, место найдено, и обновляется ссылка left или right у parent.
   5) Вставка (рекурсивная): Функция вставки часто реализуется так, что она возвращает новый корень поддерева. Поэтому при вызове необходимо присвоить результат обратно полю root, чтобы обработать случай изначально пустого дерева (tree.root = insert_recursively(tree.root, x)).
 - Java:
   1)  Связи и Null: Для связи узлов используются ссылки на объекты. Поля-ссылки (на дочерние узлы left и right) по умолчанию инициализируются значением null, если им не присвоено другое значение.
   2)  Классы: Узел (Node) часто реализуется как отдельный класс или как внутренний статический класс внутри класса Tree.
   3)  Вставка (нерекурсивная): При нерекурсивной вставке необходимо поддерживать две переменные: одну для текущего узла (node) и одну для его предка (parent). Когда node становится null, место для вставки найдено, и ссылка обновляется у parent.
 - C++:
   1) Указатели: Это ключевая особенность. Для связывания вершин используются указатели (например, TNode*).
   2)  Инициализация: Поля-указатели (Left, Right) необходимо обнулять явно в конструкторе (используя 0, NULL или, что предпочтительнее, nullptr). Чтение неинициализированного указателя приводит к неопределенному поведению.
   3)  Освобождение: Необходимо явно освобождать память. В классе дерева (TTree) логично реализовать деструктор (~TTree), который рекурсивно удалит все узлы дерева при уничтожении объекта.
   4)  Указатели на указатели: C++ позволяет использовать указатели на указатели (например, TNode** cur). Эта возможность, отсутствующая в Java, позволяет реализовать более простую нерекурсивную вставку. Переменная *cur напрямую ссылается на указатель (Left, Right или Root), который нужно изменить, что избавляет от необходимости хранить отдельную ссылку на родительский узел.
2. Описание реализации Графов на языках Python, Java, C++:
   - Python:
     1) Представление графа: Наиболее идиоматичным (естественным для языка) способом является использование словарей (dict). Граф представляется как словарь, где ключи — это вершины, а значения — это вложенные словари, содержащие соседей и веса ребер (graph = {'A': {'B': 1, 'C': 3}, ...}).
     2) Очередь с приоритетом: Используется модуль heapq, который предоставляет функции для работы с кучей (heap) на базе обычного списка Python.
     3) Бесконечность": Для инициализации расстояний используется float('infinity').
   - Java:
     1) Представление графа: Матрица смежности: int adjMat[][], список смежности: Массив списков, например ArrayList<Edge>[] graph.
     2) Очередь с приоритетом: При использовании PriorityQueue необходимо создать вспомогательный класс (например, Pair) для хранения вершины и веса. Этот класс должен реализовывать интерфейс Comparable, чтобы очередь могла корректно упорядочивать элементы.
   - C++:
     1) Представление графа: Часто используется список смежности на основе векторов, например vector<vector<Edge>> graph, где Edge — вспомогательная структура.
     2) Очередь с приоритетом: Используется встроенная std::priority_queue из стандартной библиотеки.
     3) "Бесконечность": Для инициализации расстояний используется numeric_limits<int>::max().
