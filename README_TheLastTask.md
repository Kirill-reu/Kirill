Задание 9. Метод ветвей и границ (приближённый) 
===================
Условие. Решить задачу о рюкзаке (0-1) приближённо: отсортировать предметы по удельной стоимости и жадно набирать. 

Алгоритм: жадная эвристика для рюкзака. 

Язык примера: C++

```int knapsackGreedy(vector<int> weights, vector<int> values, int W) { 
vector<pair<double, int>> items; // (удельная стоимость, индекс) 
for (int i = 0; i < weights.size(); i++) { 
items.push_back({(double)values[i]/weights[i], i}); 
} 
sort(items.rbegin(), items.rend()); 
int totalValue = 0, totalWeight = 0; 
for (auto& p : items) { 
int i = p.second; 
// ДОПИСАТЬ: если вес позволяет, взять предмет 
} 
return totalValue; 
}
```
Что дописать: проверку веса и добавление предмета.

Выполнение задания
===================
 - Анализ выполнения данного задания:
 1) ​Инициализация контейнера для удельной стоимости. Нам нужно хранить отношение «цена/вес» и индекс, чтобы не потерять связь с исходными массивами весов и цен. ```vector<pair<double, int>> items```
 2) Расчет удельной стоимости (эвристика). Мы проходим по всем предметам и вычисляем, сколько "ценности" приходится на 1 единицу веса.​ ```items.push_back({(double)values[i] / weights[i], i})```
 3) Самый важный шаг жадного алгоритма — упорядочить предметы от самых "выгодных" (высокая удельная стоимость) к менее выгодным. Используем обратные итераторы (rbegin, rend) для сортировки по убыванию. ```​sort(items.rbegin(), items.rend())```
 4) Перебор отсортированных предметов (Жадный цикл). Мы идем по списку от самого выгодного предмета. ```​for (auto& p : items) { int i = p.second; ... }```
 5) Проверка ограничения веса (То, что требовалось дописать). Перед тем как взять предмет, мы должны убедиться, что текущий вес рюкзака плюс вес нового предмета не превышают вместимость W. ```​if (totalWeight + weights[i] <= W) { ... }```
 6) Добавление предмета. Если проверка пройдена, мы "кладем" предмет в рюкзак: обновляем занятый вес и накопленную ценность. ```​totalWeight += weights[i]; totalValue += values[i]```
