Задание 9. Метод ветвей и границ (приближённый) 
===================
Условие. Решить задачу о рюкзаке (0-1) приближённо: отсортировать предметы по удельной стоимости и жадно набирать. 

Алгоритм: жадная эвристика для рюкзака. 

Язык примера: C++

```int knapsackGreedy(vector<int> weights, vector<int> values, int W) { 
vector<pair<double, int>> items; // (удельная стоимость, индекс) 
for (int i = 0; i < weights.size(); i++) { 
items.push_back({(double)values[i]/weights[i], i}); 
} 
sort(items.rbegin(), items.rend()); 
int totalValue = 0, totalWeight = 0; 
for (auto& p : items) { 
int i = p.second; 
// ДОПИСАТЬ: если вес позволяет, взять предмет 
} 
return totalValue; 
}
```
Что дописать: проверку веса и добавление предмета.

Выполнение задания
===================
 - Анализ выполнения данного задания:
 1) ​Инициализация контейнера для удельной стоимости. Нам нужно хранить отношение «цена/вес» и индекс, чтобы не потерять связь с исходными массивами весов и цен. ```vector<pair<double, int>> items```
 2) Расчет удельной стоимости (эвристика). Мы проходим по всем предметам и вычисляем, сколько "ценности" приходится на 1 единицу веса.​ ```items.push_back({(double)values[i] / weights[i], i})```
 3) Самый важный шаг жадного алгоритма — упорядочить предметы от самых "выгодных" (высокая удельная стоимость) к менее выгодным. Используем обратные итераторы (rbegin, rend) для сортировки по убыванию. ```​sort(items.rbegin(), items.rend())```
 4) Перебор отсортированных предметов (Жадный цикл). Мы идем по списку от самого выгодного предмета. ```​for (auto& p : items) { int i = p.second; ... }```
 5) Проверка ограничения веса (То, что требовалось дописать). Перед тем как взять предмет, мы должны убедиться, что текущий вес рюкзака плюс вес нового предмета не превышают вместимость W. ```​if (totalWeight + weights[i] <= W) { ... }```
 6) Добавление предмета. Если проверка пройдена, мы "кладем" предмет в рюкзак: обновляем занятый вес и накопленную ценность. ```​totalWeight += weights[i]; totalValue += values[i]```
 - Временная сложность - O(N log N)
 - Почему такая временная сложность:
    1) Вычисление удельной стоимости: Цикл for проходит по вектору из N элементов один раз, выполняя операции деления и вставки. Это занимает линейное время — O(N)
    2) Сортировка (std::sort): Это самая трудоемкая операция. Стандартная сортировка в C++ (обычно Introsort) работает за O(N log N).
    3) Жадный перебор: Второй цикл for снова проходит по списку из N предметов один раз, выполняя простые арифметические операции и проверки. Это занимает линейное время — O(N).
  
**Итоговая оценка**. Складываем сложности этапов: O(N) + O(N log N) + O(N). В асимптотическом анализе мы оставляем только самое быстрорастущее слагаемое. Так как N \log N растет быстрее, чем просто N, общая сложность определяется сортировкой.

Контрольный вопрос №9
======
**Жадный алгоритм для покрытия множеств**

Какой коэффициент аппроксимации имеет жадный алгоритм для задачи о покрытии множеств 
и почему?

Ответ на контрольный вопрос
=======
Коэффициент аппроксимации жадного алгоритма для задачи о покрытии множеств составляет H_n = ln(n) (где n — количество элементов в универсальном множестве).
​В нотации "O-большое" это записывается как: O(ln n)

**Подробное объяснение (Почему?):**
 1) **Интуитивное понимание:**
Жадный алгоритм на каждом шаге выбирает то множество, которое покрывает максимальное количество еще не покрытых элементов. В начале алгоритм работает очень эффективно, покрывая большие "куски" элементов. Однако, чем ближе конец, тем меньше непокрытых элементов остается, и алгоритму приходится выбирать множества, которые покрывают всё меньше и меньше новых элементов. Эта убывающая эффективность суммируется и дает логарифмический рост.
 2) **Математическое обоснование (через Гармонический ряд):**
Чтобы понять, откуда берется логарифм, часто используют метод "распределения стоимости".
   - Пусть OPT — это количество множеств в оптимальном (минимальном) решении.
   - На каждом шаге жадный алгоритм выбирает множество, которое покрывает k новых элементов. Мы "платим" за выбор этого множества 1 единицу (или стоимость 1).
   - Размажем эту стоимость равномерно по покрытым элементам: каждый из k элементов получает "цену" 1/k.

В худшем случае, если у нас есть n элементов, сумма этих цен для всех элементов будет ограничена n-м гармоническим числом (H_n):
```H(n) = 1 + 1/2 + 1/3 + ... + 1/n = ln(n)```

 3)  **Логика доказательства:**
     Представьте, что оптимальное решение может покрыть оставшиеся элементы за OPT множеств. Это значит, что существует хотя бы одно множество, которое покрывает не менее 1/ОРТ части от оставшихся элементов. Жадный алгоритм выберет множество, которое покрывает не меньше этого количества.
Следовательно, на каждом шаге мы сокращаем количество непокрытых элементов с определенной скоростью. Анализ этого процесса показывает, что жадное решение будет хуже оптимального не более чем в H_n раз.

**Итог:**
Жадный алгоритм находит покрытие, размер которого не превышает OPT * H_n. Это считается очень хорошим результатом, так как доказано, что добиться существенно лучшего приближения за полиномиальное время невозможно (если P != NP).
